{"version":3,"file":"wellbeyond-diagnostic-engine.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["// @ts-ignore\nimport { Engine, Rule, Fact, Almanac, RuleResult, Event, EngineResult } from 'json-rules-engine';\nimport {Diagnostic, Solution, Symptom, PotentialSolution, PotentialRootCause} from \"./types\";\n\nexport type DiagnosticCallback = {\n    (diagnostic:Diagnostic): Promise<string|number>;\n}\n\nexport type SolutionCallback = {\n    (solution:Solution): Promise<string>;\n}\n\nclass DiagnosticEngine {\n    private readonly engine: Engine;\n    private symptoms: Symptom[] = [];\n    private solutions: {\n        [solutionId:string]: Solution\n    } = {};\n    private diagnostics: {\n        [diagnosticId:string]: Diagnostic\n    } = {};\n    private factCreated: {\n        [diagnosticId:string]: boolean\n    } = {};\n    private currentSymptoms: string[] = [];\n    private rules: Rule[] = [];\n    private diagnosticCallback?:DiagnosticCallback;\n    private solutionCallback?:SolutionCallback;\n    private factPriority:number = 1000;\n    public initialized = false;\n\n    public constructor () {\n        this.engine = new Engine([], {allowUndefinedFacts: false});\n    }\n\n    public initialize (symptoms:Symptom[], solutions:Solution[], diagnostics:Diagnostic[],\n                        diagnosticCallback:DiagnosticCallback, solutionCallback:SolutionCallback): DiagnosticEngine {\n        this.symptoms = symptoms || [];\n        solutions.forEach((solution) => {\n            this.solutions[solution.id] = solution;\n        });\n        diagnostics.forEach((diagnostic) => {\n            this.diagnostics[diagnostic.id] = diagnostic;\n        });\n        this.diagnosticCallback = diagnosticCallback;\n        this.solutionCallback = solutionCallback;\n        this.parse();\n        this.initialized = true;\n        return this;\n    }\n\n    public async run(symptoms:string[], systemTypes:string[]): Promise<EngineResult> {\n        const self = this;\n        self.currentSymptoms = symptoms;\n        self.engine.addFact('symptoms', (_params, _almanac) => {\n            return self.currentSymptoms;\n        }, { cache: false, priority: 99999 });\n        self.engine.addFact('systemTypes', systemTypes, { cache: true, priority: 99999 });\n\n        self.engine\n            .on('solved', (event:any) => {\n                console.log('solved', event);\n                if (event.symptomId) {\n                    const index = self.currentSymptoms.indexOf(event.symptomId);\n                    if (index > -1) {\n                        self.currentSymptoms.splice(index, 1);\n                    }\n                }\n            })\n            .on('addSymptom', (event:any) => {\n                console.log('addSymptom', event);\n                if (event.symptomId) {\n                    const index = self.currentSymptoms.indexOf(event.symptomId);\n                    if (index == -1) {\n                        self.currentSymptoms.push(event.symptomId);\n                    }\n                }\n            })\n            .on('success', event => {\n                console.log('success', event);\n            })\n            .on('failure', event => {\n                console.log('failure', event);\n            });\n\n        return this.engine.run();\n\n    }\n\n    private parse ():void {\n        const self = this;\n        self.engine.addOperator('containsOneOf', (factValue:string[], jsonValue:string[]) => {\n            if (!factValue || !factValue.length) return false;\n            if (!jsonValue || !jsonValue.length) return false;\n            let contains:boolean = false;\n            jsonValue.forEach(val => {\n                if (factValue.includes(val)) contains = true;\n            });\n            return contains;\n        })\n        self.symptoms.forEach((symptom) => {\n            symptom.rules && symptom.rules.forEach((potential) => {\n                const solution = this.solutions[potential.solutionId];\n                if (solution) {\n                    const rule = this.createRuleForSolution(symptom, potential, solution);\n                    this.rules.push(rule);\n                }\n            });\n            symptom.rootCauses && symptom.rootCauses.forEach((cause) => {\n                const root = this.symptoms.find(s => s.id === cause.symptomId);\n                if (root) {\n                    const rule = this.createRuleForRootCause(symptom, cause, root);\n                    this.rules.push(rule);\n                }\n            });\n        });\n        self.addRules(self.rules);\n    }\n\n    private createDiagnosticFact(factId:string) {\n        const self = this;\n        if (factId && !self.factCreated[factId]) {\n            self.factCreated[factId] = true;\n            // @ts-ignore\n            this.engine.addFact(factId, function (params, almanac) {\n                return new Promise<any>((resolve, reject) => {\n                    const diagnostic = self.diagnostics[factId];\n                    console.log('Asking question ...', diagnostic);\n                    if (diagnostic && self.diagnosticCallback) {\n                        return self.diagnosticCallback(diagnostic).then((answer) => {\n                            resolve(answer);\n                        }, (reason) => {\n                            reject(reason);\n                        });\n                    } else {\n                        return reject();\n                    }\n                });\n            }, {cache: true, priority: self.factPriority--});\n        }\n    }\n\n    private createRuleForSolution(symptom:Symptom, potential:PotentialSolution, solution:Solution):Rule {\n        const self = this;\n        const rule: any = {};\n        rule.name = symptom.name + ': ' + solution.name;\n        rule.event = {\n            type: 'solved',\n            params: {\n                symptomId: symptom.id,\n                solutionId: solution.id,\n                message: solution.name\n            }\n        }\n        this.addConditions(rule, symptom, potential);\n        if (solution.askDidItWork) {\n            rule.conditions.all.push({fact: solution.id, operator: 'equal', value: 'yes'});\n            // @ts-ignore\n            this.engine.addFact(solution.id, function (params, almanac) {\n                return new Promise<any>((resolve, reject) => {\n                    if (self.solutionCallback) {\n                        console.log('Checking to see if this worked...', solution);\n                        return self.solutionCallback(solution).then((answer) => {\n                            resolve(answer);\n                        }, (reason) => {\n                            reject(reason);\n                        });\n                    }\n                    else {\n                        return reject();\n                    }\n                });\n            }, {cache: false, priority: self.factPriority--});\n        }\n        return new Rule(rule);\n    }\n\n    private createRuleForRootCause(symptom:Symptom, potential:PotentialRootCause, root:Symptom):Rule {\n        const rule: any = {};\n        rule.name = symptom.name + ': ' + root.name;\n        rule.event = {\n            type: 'addSymptom',\n            params: {\n                symptomId: symptom.id,\n                causeId: root.id,\n                message: root.name\n            }\n        }\n        this.addConditions(rule, symptom, potential);\n        return new Rule(rule);\n    }\n\n    private addConditions (rule:any, symptom:Symptom, potential:PotentialRootCause|PotentialSolution):void {\n        const self = this;\n        rule.conditions = {\n            all: [\n                {\n                    fact: 'symptoms',\n                    operator: 'contains',\n                    value: symptom.id\n                }\n            ]\n        };\n        if (potential.systemTypes && potential.systemTypes.length) {\n            rule.conditions.all.push(\n                {\n                    fact: 'systemTypes',\n                    operator: 'containsOneOf',\n                    value: potential.systemTypes\n                });\n        }\n        if (potential.mustBeYes) {\n            potential.mustBeYes.forEach((diagnosticId) => {\n                rule.conditions.all.push(\n                    {\n                        fact: diagnosticId,\n                        operator: 'equal',\n                        value: 'yes'\n                    });\n                self.createDiagnosticFact(diagnosticId);\n            });\n        }\n        potential.mustBeNo && potential.mustBeNo.forEach((diagnosticId) => {\n            rule.conditions.all.push(\n                {\n                    fact: diagnosticId,\n                    operator: 'equal',\n                    value: 'no'\n                });\n            self.createDiagnosticFact(diagnosticId);\n        });\n    }\n\n    private addRules (rules:Rule[] = []):void {\n        let priority = rules.length + 1;\n        rules.forEach((rule) => {\n            rule.setPriority(priority--);\n            this.engine.addRule(rule);\n        });\n    }\n\n    public getEngine ():Engine {\n        return this.engine;\n    }\n\n}\n\nexport {\n    DiagnosticEngine,\n    EngineResult,\n    Engine,\n    Rule,\n    Fact,\n    Almanac,\n    RuleResult,\n    Diagnostic,\n    Solution,\n    Symptom\n}"],"names":["constructor","engine","Engine","allowUndefinedFacts","initialize","symptoms","solutions","diagnostics","diagnosticCallback","solutionCallback","forEach","solution","id","diagnostic","parse","initialized","this","systemTypes","self","currentSymptoms","addFact","_params","_almanac","cache","priority","on","event","console","log","symptomId","index","indexOf","splice","push","run","addOperator","factValue","jsonValue","length","contains","val","includes","symptom","rules","potential","solutionId","rule","createRuleForSolution","rootCauses","cause","root","find","s","createRuleForRootCause","addRules","createDiagnosticFact","factId","factCreated","params","almanac","Promise","resolve","reject","then","answer","reason","factPriority","name","type","message","addConditions","askDidItWork","conditions","all","fact","operator","value","Rule","causeId","mustBeYes","diagnosticId","mustBeNo","setPriority","addRule","getEngine"],"mappings":"0dAYA,MAmBIA,4BAjB8B,kBAG1B,oBAGA,oBAGA,wBACgC,cACZ,qBAGM,sBACT,OAGZC,OAAS,IAAIC,SAAO,GAAI,CAACC,qBAAqB,IAGhDC,WAAYC,EAAoBC,EAAsBC,EACzCC,EAAuCC,eAClDJ,SAAWA,GAAY,GAC5BC,EAAUI,QAASC,SACVL,UAAUK,EAASC,IAAMD,IAElCJ,EAAYG,QAASG,SACZN,YAAYM,EAAWD,IAAMC,SAEjCL,mBAAqBA,OACrBC,iBAAmBA,OACnBK,aACAC,aAAc,EACZC,eAGMX,EAAmBY,SAC1BC,EAAOF,YACbE,EAAKC,gBAAkBd,EACvBa,EAAKjB,OAAOmB,QAAQ,WAAY,CAACC,EAASC,IAC/BJ,EAAKC,gBACb,CAAEI,OAAO,EAAOC,SAAU,QAC7BN,EAAKjB,OAAOmB,QAAQ,cAAeH,EAAa,CAAEM,OAAO,EAAMC,SAAU,QAEzEN,EAAKjB,OACAwB,GAAG,SAAWC,OACXC,QAAQC,IAAI,SAAUF,GAClBA,EAAMG,UAAW,OACXC,EAAQZ,EAAKC,gBAAgBY,QAAQL,EAAMG,WAC7CC,GAAS,GACTZ,EAAKC,gBAAgBa,OAAOF,EAAO,MAI9CL,GAAG,aAAeC,IACfC,QAAQC,IAAI,aAAcF,GACtBA,EAAMG,YAEQ,GADAX,EAAKC,gBAAgBY,QAAQL,EAAMG,YAE7CX,EAAKC,gBAAgBc,KAAKP,EAAMG,aAI3CJ,GAAG,UAAWC,IACXC,QAAQC,IAAI,UAAWF,KAE1BD,GAAG,UAAWC,IACXC,QAAQC,IAAI,UAAWF,KAGxBV,KAAKf,OAAOiC,MAIfpB,QACSE,KACRf,OAAOkC,YAAY,gBAAiB,CAACC,EAAoBC,SACrDD,IAAcA,EAAUE,OAAQ,OAAO,MACvCD,IAAcA,EAAUC,OAAQ,OAAO,MACxCC,GAAmB,SACvBF,EAAU3B,QAAQ8B,IACVJ,EAAUK,SAASD,KAAMD,GAAW,KAErCA,IAREvB,KAURX,SAASK,QAASgC,IACnBA,EAAQC,OAASD,EAAQC,MAAMjC,QAASkC,UAC9BjC,EAAWK,KAAKV,UAAUsC,EAAUC,eACtClC,EAAU,OACJmC,EAAO9B,KAAK+B,sBAAsBL,EAASE,EAAWjC,QACvDgC,MAAMV,KAAKa,MAGxBJ,EAAQM,YAAcN,EAAQM,WAAWtC,QAASuC,UACxCC,EAAOlC,KAAKX,SAAS8C,KAAKC,GAAKA,EAAExC,KAAOqC,EAAMpB,cAChDqB,EAAM,OACAJ,EAAO9B,KAAKqC,uBAAuBX,EAASO,EAAOC,QACpDP,MAAMV,KAAKa,QAtBf9B,KA0BRsC,SA1BQtC,KA0BM2B,OAGfY,qBAAqBC,SACnBtC,EAAOF,KACTwC,IAAWtC,EAAKuC,YAAYD,KAC5BtC,EAAKuC,YAAYD,IAAU,OAEtBvD,OAAOmB,QAAQoC,GAAQ,SAAUE,EAAQC,UACnC,IAAIC,QAAa,CAACC,EAASC,WACxBjD,EAAaK,EAAKX,YAAYiD,UACpC7B,QAAQC,IAAI,sBAAuBf,GAC/BA,GAAcK,EAAKV,mBACZU,EAAKV,mBAAmBK,GAAYkD,KAAMC,IAC7CH,EAAQG,IACRC,IACAH,EAAOG,KAGJH,QAGhB,CAACvC,OAAO,EAAMC,SAAUN,EAAKgD,kBAIhCnB,sBAAsBL,EAAiBE,EAA6BjC,SAClEO,EAAOF,KACP8B,EAAY,UAClBA,EAAKqB,KAAOzB,EAAQyB,KAAO,KAAOxD,EAASwD,KAC3CrB,EAAKpB,MAAQ,CACT0C,KAAM,SACNV,OAAQ,CACJ7B,UAAWa,EAAQ9B,GACnBiC,WAAYlC,EAASC,GACrByD,QAAS1D,EAASwD,YAGrBG,cAAcxB,EAAMJ,EAASE,GAC9BjC,EAAS4D,eACTzB,EAAK0B,WAAWC,IAAIxC,KAAK,CAACyC,KAAM/D,EAASC,GAAI+D,SAAU,QAASC,MAAO,aAElE3E,OAAOmB,QAAQT,EAASC,IAAI,SAAU8C,EAAQC,UACxC,IAAIC,QAAa,CAACC,EAASC,IAC1B5C,EAAKT,kBACLkB,QAAQC,IAAI,oCAAqCjB,GAC1CO,EAAKT,iBAAiBE,GAAUoD,KAAMC,IACzCH,EAAQG,IACRC,IACAH,EAAOG,MAIJH,OAGhB,CAACvC,OAAO,EAAOC,SAAUN,EAAKgD,kBAE9B,IAAIW,OAAK/B,GAGZO,uBAAuBX,EAAiBE,EAA8BM,SACpEJ,EAAY,UAClBA,EAAKqB,KAAOzB,EAAQyB,KAAO,KAAOjB,EAAKiB,KACvCrB,EAAKpB,MAAQ,CACT0C,KAAM,aACNV,OAAQ,CACJ7B,UAAWa,EAAQ9B,GACnBkE,QAAS5B,EAAKtC,GACdyD,QAASnB,EAAKiB,YAGjBG,cAAcxB,EAAMJ,EAASE,GAC3B,IAAIiC,OAAK/B,GAGZwB,cAAexB,EAAUJ,EAAiBE,SACxC1B,EAAOF,KACb8B,EAAK0B,WAAa,CACdC,IAAK,CACD,CACIC,KAAM,WACNC,SAAU,WACVC,MAAOlC,EAAQ9B,MAIvBgC,EAAU3B,aAAe2B,EAAU3B,YAAYqB,QAC/CQ,EAAK0B,WAAWC,IAAIxC,KAChB,CACIyC,KAAM,cACNC,SAAU,gBACVC,MAAOhC,EAAU3B,cAGzB2B,EAAUmC,WACVnC,EAAUmC,UAAUrE,QAASsE,IACzBlC,EAAK0B,WAAWC,IAAIxC,KAChB,CACIyC,KAAMM,EACNL,SAAU,QACVC,MAAO,QAEf1D,EAAKqC,qBAAqByB,KAGlCpC,EAAUqC,UAAYrC,EAAUqC,SAASvE,QAASsE,IAC9ClC,EAAK0B,WAAWC,IAAIxC,KAChB,CACIyC,KAAMM,EACNL,SAAU,QACVC,MAAO,OAEf1D,EAAKqC,qBAAqByB,KAI1B1B,SAAUX,EAAe,QACzBnB,EAAWmB,EAAML,OAAS,EAC9BK,EAAMjC,QAASoC,IACXA,EAAKoC,YAAY1D,UACZvB,OAAOkF,QAAQrC,KAIrBsC,mBACIpE,KAAKf"}